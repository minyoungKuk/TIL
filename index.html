<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Minyoung's Diary</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC"
      crossorigin="anonymous"
    />
    <link rel="stylesheet" href="./css/reset.css" />
    <link rel="stylesheet" href="./css/style.css" />

    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
      crossorigin="anonymous"
    ></script>
    <script type="module" src="./js/main.js"></script>
  </head>
  <body>
    <div class="wrap">
      <div class="header">
        <a href="https://minyoungkuk.github.io/TIL/" class="home"
          >Minyoung's diary</a
        >
        <nav>
          <ul>
            <li class="active"><a href="./index.html">TIL</a></li>
            <li><a href="">기술일지</a></li>
            <li><a href="">참고자료</a></li>
            <li><a href="./todo/index.html">Todo</a></li>
          </ul>
        </nav>
      </div>

      <div class="main">
        <h2>TIL - <span>오늘의 내가 새롭게 알게 된 것 📝</span></h2>

        <div>
          <div class="accordion" id="accordionExample">
            <!-- items st -->
            <div class="accordion-item">
              <h2 class="accordion-header">
                <button
                  class="accordion-button collapsed"
                  type="button"
                  data-bs-toggle="collapse"
                  data-bs-target="#collapse_0425"
                  aria-expanded="false"
                  aria-controls="collapse_0425"
                >
                  <span class="smalltxt">2024.04.26.금</span> JS 문법 종합반 -
                  콜백함수, Promise, async await / 알고리즘 특강
                </button>
              </h2>
              <div
                id="collapse_0425"
                class="accordion-collapse collapse"
                data-bs-parent="#accordionExample"
              >
                <div class="accordion-body">
                  <div class="inner">
                    <div class="title">강의 내용 정리</div>
                    <div class="contents">
                      <strong>Promise</strong> <br />
                      비동기 처리에 대해, 처리가 끝나면 알려달라는 ‘약속’<br />
                      <code>
                        var addCoffee = function (name) {<br />
                        return function (prevName) {<br />
                        return new Promise(function (resolve) {<br />
                        setTimeout(function () {<br />
                        var newName = prevName ? (prevName + ', ' + name) :
                        name;<br />
                        console.log(newName);<br />
                        resolve(newName);<br />
                        }, 500);<br />
                        });<br />
                        };<br />
                        };<br /><br />

                        addCoffee('에스프레소')()<br />
                        .then(addCoffee('아메리카노'))<br />
                        .then(addCoffee('카페모카'))<br />
                        .then(addCoffee('카페라떼'));<br /><br />
                      </code>

                      <strong>Generator</strong><br />
                      *가 붙은 함수가 제너레이터 함수<br />
                      제너레이터 함수는 실행하면, Iterator 객체가 반환(next()를
                      가지고 있음)<br />
                      비동기 작업이 완료되는 시점마다 next 메서드를 호출해주면
                      Generator 함수 내부소스가 위 -> 아래 순차적으로 진행<br />
                      <code>
                        var addCoffee = function (prevName, name) {<br />
                        setTimeout(function () {<br />
                        coffeeMaker.next(prevName ? prevName + ', ' + name :
                        name);<br />
                        }, 500);<br />
                        };<br /><br />
                        var coffeeGenerator = function* () {<br />
                        var espresso = yield addCoffee('', '에스프레소');<br />
                        console.log(espresso);<br />
                        var americano = yield addCoffee(espresso,
                        '아메리카노');<br />
                        console.log(americano);<br />
                        var mocha = yield addCoffee(americano, '카페모카');<br />
                        console.log(mocha);<br />
                        var latte = yield addCoffee(mocha, '카페라떼');<br />
                        console.log(latte);<br />
                        };<br /><br />
                        var coffeeMaker = coffeeGenerator();<br />
                        coffeeMaker.next();<br /><br />
                      </code>

                      <strong>Promise + Async/await</strong><br />
                      Promise ~ then과 동일한 효과<br />
                      <code>
                        var addCoffee = function (name) {<br />
                        return new Promise(function (resolve) {<br />
                        setTimeout(function(){<br />
                        resolve(name);<br />
                        }, 500);<br />
                        });<br />
                        };<br /><br />
                        var coffeeMaker = async function () {<br />
                        var coffeeList = '';<br />
                        var _addCoffee = async function (name) {<br />
                        coffeeList += (coffeeList ? ', ' : '') + await
                        addCoffee(name);<br />
                        };<br />
                        await _addCoffee('에스프레소');<br />
                        console.log(coffeeList);<br />
                        await _addCoffee('아메리카노');<br />
                        console.log(coffeeList);<br />
                        await _addCoffee('카페모카');<br />
                        console.log(coffeeList);<br />
                        await _addCoffee('카페라떼');<br />
                        console.log(coffeeList);<br />
                        };<br />
                        coffeeMaker();<br /><br />
                      </code>
                    </div>
                  </div>
                  <!-- <div class="inner">
                    <div class="title">개발 단계 정리</div>
                    <div class="contents">
                      튜터님께 코드 보여드리고, 다시 사용할 수도 있는 함수를
                      따로 빼주는 것에 대한 피드백을 받은 후 리팩토링하는 시간을
                      가졌다.
                    </div>
                  </div> -->
                  <div class="inner">
                    <div class="title">하루 회고</div>
                    <div class="contents">
                      강의를 들으며 새로운 지식들이 갑자기 너무 많이 생겨서
                      어렵다 .. ㅎㅎ <br />
                      꼭 다시 한번 돌려야겠다.
                    </div>
                  </div>
                  <div class="inner">
                    <div class="title">문제 해결 과정</div>
                    <div class="contents">
                      <strong>아래의 코드를 async/await 로 리팩토링</strong
                      ><br />
                      <code>
                        class HttpError extends Error { <br />
                        constructor(response) { <br />
                        super(`${response.status} for ${response.url}`); <br />
                        this.name = 'HttpError'; <br />
                        this.response = response; <br />
                        } <br />
                        } <br />
                        <br />

                        function loadJson(url) { <br />
                        return fetch(url) <br />
                        .then(response => { <br />
                        if (response.status == 200) { <br />
                        return response.json(); <br />
                        } else { <br />
                        throw new HttpError(response); <br />
                        } <br />
                        }) <br />
                        } <br />
                        <br />

                        function narutoIsNotOtaku() { <br />
                        let title = prompt("애니메이션 제목을 입력하세요.",
                        "naruto"); <br />
                        <br />

                        return
                        loadJson(`https://animechan.xyz/api/random/anime?title=${title}`)
                        <br />
                        .then(res => { <br />
                        alert(`${res.character}: ${res.quote}.`); <br />
                        return res; <br />
                        }) <br />
                        .catch(err => { <br />
                        if (err instanceof HttpError && err.response.status ==
                        404) { <br />
                        alert("일치하는 애니메이션이 없습니다. 일반인이시면
                        naruto, onepiece 정도나 <br />입력해주세요!"); <br />
                        return narutoIsNotOtaku(); <br />
                        } else { <br />
                        throw err; <br />
                        } <br />
                        }); <br />
                        } <br />
                        <br />

                        narutoIsNotOtaku(); <br /><br /><br />
                      </code>

                      일단 모르는 메서드?가 많아서 더 어렵게 느껴졌다. <br />
                      문제에 위의 class HttpError extends Error 부분은 수정이
                      필요 없다고 했으니, 제외하고 수정을 하면 되는 문제였다.
                      <br />
                      이런 문제는 처음 풀어봐서 처음 봤을때는 너무 어렵게
                      느껴졌지만 이전 강의를 들으며 필기했던것을 참고하고,
                      구글링도 하고 ㅎㅎ 하며 결국 풀었다! <br />
                      밑에 코드는 내가 제출한 코드인데 코드에서 풀이과정을
                      설명해보겠다. <br /><br />

                      <code>
                        const loadJson = async (url) => { <br />
                        const response = await fetch(url); // fetch를 사용하여
                        데이터를 가져온 후에 response 객체의 status를 체크
                        <br />
                        // 성공적으로 데이터를 불러오면 JSON 데이터를
                        resolve하고, 그렇지 않으면 HttpError를 throw <br />
                        if (!response.ok) { <br />
                        throw new HttpError(response); <br />
                        } <br />
                        return response.json(); <br />
                        }; <br /><br />

                        // 애니메이션 정보를 가져오는 비동기 함수를 정의합니다.
                        <br />
                        const narutoIsNotOtaku = async () => { <br />
                        let title = prompt("애니메이션 제목을 입력하세요.",
                        "naruto"); <br /><br />

                        try { <br />
                        // 입력받은 제목으로 API에서 JSON 데이터를 로드하고
                        await를 사용하여 응답을 기다림 const res = await
                        loadJson( <br />
                        `https://animechan.xyz/api/random/anime?title=${title}`
                        ); <br />
                        alert(`${res.character}: ${res.quote}.`);<br />
                        return res;<br />
                        } catch (err) {<br />
                        if (err instanceof HttpError && err.response.status ==
                        404) {<br />
                        alert(<br />
                        "일치하는 애니메이션이 없습니다. 일반인이시면 naruto,
                        onepiece 정도나 입력해주세요!"<br />
                        );<br />
                        return narutoIsNotOtaku();<br />
                        } else {<br />
                        throw err;<br />
                        }<br />
                        }<br />
                        };
                        <br /><br />
                        // 애니메이션 정보를 다시 입력받도록 재귀적으로 함수를
                        호출<br />
                        narutoIsNotOtaku();<br />
                      </code>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <!-- items nd -->

            <!-- items st -->
            <div class="accordion-item">
              <h2 class="accordion-header">
                <button
                  class="accordion-button collapsed"
                  type="button"
                  data-bs-toggle="collapse"
                  data-bs-target="#collapse_0425"
                  aria-expanded="false"
                  aria-controls="collapse_0425"
                >
                  <span class="smalltxt">2024.04.25.목</span> JS 문법 종합반 -
                  실행 컨텍스트 (this, call, apply, bind) / 알고리즘 특강 / 개인
                  프로젝트 마무리
                </button>
              </h2>
              <div
                id="collapse_0425"
                class="accordion-collapse collapse"
                data-bs-parent="#accordionExample"
              >
                <div class="accordion-body">
                  <div class="inner">
                    <div class="title">강의 내용 정리</div>
                    <div class="contents">
                      오늘 강의 너무 어렵다. 하하하하 <br />
                      설명을 들을땐 어렵지 않은 거 같고 이해가 되는 거 같은데,
                      막상 마무리 과제를 푸려고 하니 어렵게 느껴졌다. <br />
                      아직 제대로 학습되지 않았다는 것이라 생각하고 3주차 강의는
                      다시 돌려봐야겠다. <br />
                      오늘 강의 들은 부분 중 리마인드 해야할 것들을 정리
                      해놔야겠다.
                      <br /><br />

                      <strong>실행 컨텍스트</strong> <br />
                      - VE, LE => [recode(식별자), outer를 가지고있다.]<br />
                      1. VariableEnvironment(VE) ===> [생겼을때의 모습을
                      그대로,, 유지하는 한다.. 이걸 스냅샷이라고 한다. => 즐
                      실시간 변경 X]<br />
                      - 현재 컨텍스트 내의 식별자 정보(=recoed)를 가지고
                      있습니다 (예시: "var a = 2" 이 경우 "var a"를 의미)<br />
                      - 외부 환경 정보(=outer)를 가지고 있다.<br />
                      - 선언 시점 LexicalEnvironment의 snapshot<br />
                      2. LexicalEnvironment(LE) ===> [실시간 변경 가능!!]<br />
                      - VariableEnvironment와 동일하지만, 실시간으로 반영.<br />
                      3. ThisBinding<br />
                      - this식별자가 바라봐야할 객체.<br /><br />

                      <strong>[hoist : 들어올리다, 끌어올리다]</strong><br />
                      * 호이스팅 : 레코드수집; 호이스팅의 개념은 레코드에서
                      나온다!!!!!!! 즉 식별자 정보를 수집할때 호이스팅읠 개념이
                      등장~<br />
                      - 컨텍스트 내부를 첨부터 끝까지 순서대로 훑어가면 수집 ->
                      순서대로 수집하는거지, 코드가 실행되는것은 아님!<br />
                      변수 정보 수집 과정을 이해하기 쉽게 설명한 가상개념임.
                      ㅎ<br />
                      호이스팅을 해보면 식별자 정보만 위로 다 끌어 올린대용<br /><br />

                      <strong
                        >outer [스코프, 스코프 체인,
                        outerEnvironmentReference(이하 outer)]</strong
                      >
                      <br />
                      1. 스코프 : 식별자에 대한 유효 범위 / 대부분 언어에서
                      존재<br />
                      2. 스코프 체인 : 식별자의 유효범위를 안에서 바깥으로
                      차례대로 검색해 나가는 것<br />
                      3. outer : 스코프 체인이 가능토록 하는 것(외부 환경의
                      참조정보)라고 할 수 있어요 ⭐️현재 호출된 함수가 선언된
                      당시의 LE를 참조<br /><br />

                      호출 주체가 있는 경우의 명시적 바인딩.<br />
                      <code>
                        let obj = {<br />
                        a: 1,<br />
                        method: function (x, y) {<br />
                        console.log(this.a, x, y);<br />
                        },<br />
                        };<br />

                        // method함수 안의 this는 항상 obj!!<br />
                        obj.method(2, 3); // 1, 2, 3<br />
                        obj.method.call({ a: 4 }, 5, 6); // 4, 5, 6<br /><br />
                      </code>

                      call() 이라는 메서드는 기존에 있었던 메서드 뒤에 붙어서
                      즉시 실행을 해주되 앞에 디스로 묶을 객체를 붙혀주고나서,
                      나머지 매개변수를 넣어주면 된다.. ㅎ<br />

                      apply도 완전히 똑같지만 뒤에 있는 매개변수를 대괄호로
                      묶여줘야 한다는 것이 차이점이다.<br />
                      // obj.method.apply({ a: 4 }, [5, 6]); // 4, 5, 6<br /><br />

                      ES6 문법 나온 이후 .. 객체를 배열로 그냥 바꿔주는 메서드가
                      있다!<br />
                      <code
                        >Array.from() (예시 : var arr = Array.from(obj))</code
                      ><br /><br />

                      <strong
                        >여기서 내가 궁금한건 화살표 함수로 this를 사용하면
                        되지않나? 였다!</strong
                      ><br />
                      그래서 챗 지피티한테 물어봤다. ㅎㅎ<br /><br />
                      Answer => 네, 화살표 함수를 사용하여 this를 컨트롤하는
                      것이 때로는 더 간편하고 명확한 방법일 수 있습니다.<br />
                      화살표 함수는 자신의 this를 갖지 않고, 대신에 외부 범위의
                      this를 그대로 가져다 사용합니다. <br />이러한 특성으로
                      인해 화살표 함수는 일반적으로 this를 명시적으로 바인딩할
                      필요가 없습니다.<br />ㅍ 하지만 주의할 점이 있습니다.
                      화살표 함수의 this는 lexical scope를 따라가기 때문에,
                      화살표 함수 내부에서 this는 해당 함수가 선언된 곳의 this를
                      가리킵니다. <br />이는 때로 원하는 동작과 다를 수
                      있습니다. 예를 들어, 객체의 메서드로서 화살표 함수를
                      사용할 경우, 해당 메서드 내부에서의 this는 객체 자체가
                      아니라 상위 스코프의 this를 가리킵니다.<br />
                      때문에 메서드 내부에서 객체의 속성에 접근하거나 수정하는
                      등의 작업을 하기 위해서는 화살표 함수보다는 일반 함수를
                      사용하는 것이 적합합니다.<br /><br />

                      여기에는 call, apply, bind와 같은 메서드를 사용하여
                      명시적으로 this를 바인딩하는 것이 유용할 수 있습니다.
                      <br />특히 객체의 메서드로 사용되는 함수에서 this를 객체
                      자체로 고정시켜야 할 때 유용합니다. 이러한 메서드들을
                      사용하면 함수가 호출될 때 this를 원하는 값으로 지정할 수
                      있습니다.<br />

                      따라서 화살표 함수는 this를 다루는 데 편리한 방법이지만,
                      모든 상황에 적합하지는 않습니다. <br />상황에 따라 일반
                      함수와 call, apply, bind 메서드를 사용하는 것이 더 적합할
                      수 있습니다.<br /><br />
                      그렇다고 한다!
                    </div>
                  </div>
                  <div class="inner">
                    <div class="title">개발 단계 정리</div>
                    <div class="contents">
                      튜터님께 코드 보여드리고, 다시 사용할 수도 있는 함수를
                      따로 빼주는 것에 대한 피드백을 받은 후 리팩토링하는 시간을
                      가졌다.
                    </div>
                  </div>
                  <div class="inner">
                    <div class="title">하루 회고</div>
                    <div class="contents">
                      별거 안한거 같은데 12시간이 꽉 차는구나~ ㅜㅜ
                    </div>
                  </div>
                  <!-- <div class="inner">
                    <div class="title">문제 해결 과정</div>
                    <div class="contents">
                      <code>
                    </code>
                    </div>
                  </div> -->
                </div>
              </div>
            </div>
            <!-- items nd -->

            <!-- items st -->
            <div class="accordion-item">
              <h2 class="accordion-header">
                <button
                  class="accordion-button collapsed"
                  type="button"
                  data-bs-toggle="collapse"
                  data-bs-target="#collapse_0424"
                  aria-expanded="false"
                  aria-controls="collapse_0424"
                >
                  <span class="smalltxt">2024.04.24.수</span> JS 문법 종합반 -
                  데이터 타입 / 알고리즘 특강 / 개인 프로젝트 시작
                </button>
              </h2>
              <div
                id="collapse_0424"
                class="accordion-collapse collapse"
                data-bs-parent="#accordionExample"
              >
                <div class="accordion-body">
                  <div class="inner">
                    <div class="title">강의 내용 정리</div>
                    <div class="contents">
                      오늘은 데이터 타입 심화 강의를 들었는데, 코드치며 따라하는
                      강의보다 시간이 더 걸리는 것 같다. <br />
                      내일까지 3주차 강의를 끝내야야겠다.
                      <br /><br />

                      1. 얕은 복사, 깊은 복사 <br />
                      - 얕은 복사를 하게되면 하드코딩을 하지 않고도 객체의 모든
                      프로터티의 속성에 접근 가능하다. <br />
                      하지만 객체안에 객체까지는 접근하기 위에서는 깊은 복사를
                      사용해야 한다. <br /><br />
                      <code>
                        // 깊은 복사<br />
                        let copyObjectDeep = (target) => {<br />
                        // target 객체를 복사하여 반환<br />
                        let result = {}; // 요기에 복사된 것들이 추가
                        될것이다!<br /><br />

                        if (typeof target === "object" && target !== null) {<br />
                        // 타겟이 객체이며, 빈값이 아닌지 확인한후 밑줄의 포문
                        실행~<br />
                        for (let prop in target) {<br />
                        result[prop] = copyObjectDeep(target[prop]); //
                        재귀적으로 "copyObjectDeep"함수도 호출하여
                        <br />내부객체까지 복사.<br />
                        }<br />
                        } else {<br />
                        result = target;<br />
                        }<br />
                        return result;<br />
                        };<br /><br />
                      </code>

                      2. 실행컨텍스트: 실행할 코드에 제공할 환경정보를 모아놓은
                      객체. <br />
                      - 선언된 변수를 위로 끌어 올린다! = hoisting<br />
                      - 외부 환경 정보를 구상 <br />
                      - this값을 설정<br /><br />

                      2. 콜 스택<br />
                      <img
                        src="https://teamsparta.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F13ecd27d-f865-4f0a-b782-2992a3eabdc8%2FUntitled.png?table=block&id=e0df9a66-2ed4-4df5-a804-6898271c3f88&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=1050&userId=&cache=v2"
                        alt=""
                      />
                      <code>
                        //// * call stack flow<br />
                        let a = 1; // 1 번 // 6번 전역 아웃 후 코드 종료<br />
                        function outer() {<br />
                        // 4번 아우터 재개<br />
                        function inner() {<br />
                        console.log(a);<br />
                        a = 3; // 5번 아우터 아웃<br />
                        }<br /><br />

                        inner(); // 3번 아우터 중단 / 이너 인<br />
                        console.log(a);<br />
                        }<br />
                        outer(); // 2번 아우터 인.<br />
                        console.log(a);<br />
                      </code>
                    </div>
                  </div>
                  <div class="inner">
                    <div class="title">개발 단계 정리</div>
                    <div class="contents">1. API 연결 완.</div>
                  </div>
                  <div class="inner">
                    <div class="title">하루 회고</div>
                    <div class="contents">CS는 언제 재밌어지려나 ㅎㅎ</div>
                  </div>
                  <!-- <div class="inner">
                    <div class="title">문제 해결 과정</div>
                    <div class="contents">
                      1. 1주차 강의를 끝내며 주어진 문제를 푸는데 분명 맞게
                      풀었는데 계속 이상한 오류가 떴다. <br />
                      2-3번을 봐도 틀릴 이유를 모르겠었는데, 천천히 다시보니
                      length를 붙혀야할 곳에 빼먹은 것때문에 계속 들렸던
                      것이였다 ... ㅠㅠ <br />
                      꼼꼼하게 작성해나가는 버릇을 들여야겠디. <br /><br />
                      2. 2주차 과제에서 배열들을 순서대로 정렬하는 것은 어렵지
                      않게 했는데, <br />
                      특정 idx를 기반으로만 정렬하고 같은 문자열이라면 순서를
                      그대로 유지하는 것이 매우 어려웠다. <br />
                      <img src="./assets/img/img0423.png" alt="" />
                      이 문제인데, 처음 내가 푼 방식은 문자의 해당 인덱스의
                      문자가 같을때 문자를 그대로 배치해야한다는 것을 까먹어서
                      모든 테스트 케이스를 만족시키지 못했다. <br /><br />
                      <code>
                        function solution(strings, n) { <br />
                        // strings배열의 단어의 n번째 글자로 재정렬.<br />

                        let newArr = strings.sort((a, b) => a[n] < b[n] ? -1 :
                        (a[n] > b[n]) ? 1 : 0)<br />

                        return newArr<br />
                        }<br /><br />
                      </code>
                      ㅜㅜ 힌트를 보지않고 해결해보고 싶었는데 시간이 흘러도
                      해결방안이 잘 생각나지 않아 결국 힌트를 보게 되었다.
                      <br />
                      제공된 힌트는 해당 인덱스의 해당하는 문자를 아이템 맨앞에
                      붙힌뒤 정렬을 하고 그 이후에 맨 앞글자를 삭제하라는
                      것이였다. <br />
                      힌트에서도 좋은 방법은 아니지만 현재까지의 강의를 들은
                      우리에게 가장 쉬운 방법이라고 하니, 일단 힌트에서
                      제시한대로 문제를 푼 후 나중에 다시 풀어봐야겠다라는
                      생각이 들었다. <br />

                      <code>
                        function solution(strings, n) { <br />
                        for (let i = 0; i < strings.length; i++) { <br />
                        strings[i] = strings[i][n] + strings[i] <br />
                        } <br />
                        <br />

                        strings.sort(); <br />
                        <br />

                        for (let i = 0; i < strings.length; i++) { <br />
                        strings[i] = strings[i].split('').slice(1).join('')
                        <br />
                        } <br />
                        <br />

                        return strings <br />
                        } <br />
                      </code>
                      내가 제출하게 된 코드다. <br />
                      문자열에 n번째 단어를 붙혀 반환한 후 정렬을 하고,
                      <br />
                      문자열을 나눈후 0번째 인덱스를 빼고 다시 합쳐 반환하는
                      형식으로 풀었다. <br /><br />
                      내가 설명하면서도 좋은 풀이는 아닌거 같다. ㅜㅜ <br />
                      완강한 후 다시 풀어봐야겠다.
                    </div>
                  </div> -->
                </div>
              </div>
            </div>
            <!-- items nd -->

            <!-- items st -->
            <div class="accordion-item">
              <h2 class="accordion-header">
                <button
                  class="accordion-button collapsed"
                  type="button"
                  data-bs-toggle="collapse"
                  data-bs-target="#collapse_0423"
                  aria-expanded="false"
                  aria-controls="collapse_0423"
                >
                  <span class="smalltxt">2024.04.23.화</span> JS 문법 종합반 -
                  반복문, ES6 문법, Map, Set
                </button>
              </h2>
              <div
                id="collapse_0423"
                class="accordion-collapse collapse"
                data-bs-parent="#accordionExample"
              >
                <div class="accordion-body">
                  <div class="inner">
                    <div class="title">강의 내용 정리</div>
                    <div class="contents">
                      오늘들은 강의는 객체와 배열, 그리고 반목문에 관련된
                      것들이였다. <br />
                      기억하고 싶은 부분들이 있어 기록해놔야겠다. <br /><br />

                      1. 객체 <br />
                      - 1. 객체는 안의 내용이 똑같다고 해도 용량이 크기에
                      '주소'로서 저장되어 같은 객체를 비교해도 false로 나온다.
                      <br />
                      객체안에 문자열만을 비교하고자 한다면
                      <b>JSON.stringify()</b>를 사용하면 된다.<br /><br />
                      <code>
                        let person1 = { <br />
                        name: "홍길동", <br />
                        age: 30, <br />
                        gender: "남자", <br />
                        }; <br /><br />

                        let person2 = { <br />
                        name: "홍길동", <br />
                        age: 30, <br />
                        gender: "남자", <br />
                        };
                        <br />
                        <br />

                        console.log(person1 === person2); // false <br />
                        console.log(JSON.stringify(person1) ===
                        JSON.stringify(person2)); // true <br /><br />
                      </code>

                      2. ES6 문법 <br />
                      - 일급객체(First-class Object) : 쉽게 이야기 하자면 함수를
                      아주 유연하게 사용하도록 하는 것! <br />
                      콜백함수 : 매개변수로 함수를 받음. <br />
                      고차함수 : 함수를 인지로 받거나 return하는 함수. <br />
                    </div>
                  </div>
                  <!-- <div class="inner">
                    <div class="title">개발 단계 정리</div>
                    <div class="contents">
                      1. 설치하기2. 초기 세팅하기(코드 작성)3. OO 만들기
                    </div>
                  </div> -->
                  <div class="inner">
                    <div class="title">하루 회고</div>
                    <div class="contents">
                      오늘 인강을 들으며 자바스크림트가 얼마나 유연한 언어인지
                      다시 한번 깨닫게 되었다. <br />
                      배열안에도 함수가 들어갈수있는 건 오늘 알아서 흥미로웠다.
                    </div>
                  </div>
                  <div class="inner">
                    <div class="title">문제 해결 과정</div>
                    <div class="contents">
                      1. 1주차 강의를 끝내며 주어진 문제를 푸는데 분명 맞게
                      풀었는데 계속 이상한 오류가 떴다. <br />
                      2-3번을 봐도 틀릴 이유를 모르겠었는데, 천천히 다시보니
                      length를 붙혀야할 곳에 빼먹은 것때문에 계속 들렸던
                      것이였다 ... ㅠㅠ <br />
                      꼼꼼하게 작성해나가는 버릇을 들여야겠디. <br /><br />
                      2. 2주차 과제에서 배열들을 순서대로 정렬하는 것은 어렵지
                      않게 했는데, <br />
                      특정 idx를 기반으로만 정렬하고 같은 문자열이라면 순서를
                      그대로 유지하는 것이 매우 어려웠다. <br />
                      <img src="./assets/img/img0423.png" alt="" />
                      이 문제인데, 처음 내가 푼 방식은 문자의 해당 인덱스의
                      문자가 같을때 문자를 그대로 배치해야한다는 것을 까먹어서
                      모든 테스트 케이스를 만족시키지 못했다. <br /><br />
                      <code>
                        function solution(strings, n) { <br />
                        // strings배열의 단어의 n번째 글자로 재정렬.<br />

                        let newArr = strings.sort((a, b) => a[n] < b[n] ? -1 :
                        (a[n] > b[n]) ? 1 : 0)<br />

                        return newArr<br />
                        }<br /><br />
                      </code>
                      ㅜㅜ 힌트를 보지않고 해결해보고 싶었는데 시간이 흘러도
                      해결방안이 잘 생각나지 않아 결국 힌트를 보게 되었다.
                      <br />
                      제공된 힌트는 해당 인덱스의 해당하는 문자를 아이템 맨앞에
                      붙힌뒤 정렬을 하고 그 이후에 맨 앞글자를 삭제하라는
                      것이였다. <br />
                      힌트에서도 좋은 방법은 아니지만 현재까지의 강의를 들은
                      우리에게 가장 쉬운 방법이라고 하니, 일단 힌트에서
                      제시한대로 문제를 푼 후 나중에 다시 풀어봐야겠다라는
                      생각이 들었다. <br />

                      <code>
                        function solution(strings, n) { <br />
                        for (let i = 0; i < strings.length; i++) { <br />
                        strings[i] = strings[i][n] + strings[i] <br />
                        } <br />
                        <br />

                        strings.sort(); <br />
                        <br />

                        for (let i = 0; i < strings.length; i++) { <br />
                        strings[i] = strings[i].split('').slice(1).join('')
                        <br />
                        } <br />
                        <br />

                        return strings <br />
                        } <br />
                      </code>
                      내가 제출하게 된 코드다. <br />
                      문자열에 n번째 단어를 붙혀 반환한 후 정렬을 하고,
                      <br />
                      문자열을 나눈후 0번째 인덱스를 빼고 다시 합쳐 반환하는
                      형식으로 풀었다. <br /><br />
                      내가 설명하면서도 좋은 풀이는 아닌거 같다. ㅜㅜ <br />
                      완강한 후 다시 풀어봐야겠다.
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <!-- items nd -->

            <!-- items st -->
            <div class="accordion-item">
              <h2 class="accordion-header">
                <button
                  class="accordion-button collapsed"
                  type="button"
                  data-bs-toggle="collapse"
                  data-bs-target="#collapseOne"
                  aria-expanded="false"
                  aria-controls="collapseOne"
                >
                  <span class="smalltxt">2024.04.22.월</span> JS 문법 종합반 -
                  1주차
                </button>
              </h2>
              <div
                id="collapseOne"
                class="accordion-collapse collapse"
                data-bs-parent="#accordionExample"
              >
                <div class="accordion-body">
                  <div class="inner">
                    <div class="title">강의 내용 정리</div>
                    <div class="contents">
                      아직 강의 초반이라 익숙한 것들이 많이 나온다. <br />
                      삼항 연산자는 사용하였었는데 비슷한 느낌의 조건부 실행은
                      조금 생소했다.
                      <br />
                      강의해서 요즘 많이 사용한다고 하셨는데, <br />
                      조건부 실행에 대해서는 다시 한번 짚고 가면 좋을 것 같다.
                      <br />
                      <br />

                      1. 조건부 실행 <br />
                      <code>
                        1. and조건(&&) <br />
                        let x = 10; <br />
                        x > 0 && consolo.log("양수입니다.") // 양수입니다. 출력
                        <br />
                        <br />
                        2. or조건(||)<br />
                        let y;<br />
                        let z = y || 20; // y는 undefined로 flasy한 값이니 20이
                        출력된다.<br /><br />
                      </code>
                      2. entries : 2차원 배열로 반환해준다<br />
                      <code>
                        let person = {<br />
                        name: "홍길동",<br />
                        age: 30,<br />
                        gender: "남자",<br />
                        };<br />
                        let entries = Object.entries(person);<br />
                        console.log("entries => ", entries); // entries => [ [
                        'name', '홍길동' ], [ 'age', 30 ], [ 'gender', '남자' ]
                        ]<br />
                      </code>
                    </div>
                  </div>
                  <!-- <div class="inner">
                    <div class="title">개발 단계 정리</div>
                    <div class="contents">
                      1. 설치하기2. 초기 세팅하기(코드 작성)3. OO 만들기
                    </div>
                  </div> -->
                  <div class="inner">
                    <div class="title">하루 회고</div>
                    <div class="contents">
                      JS 문법 강의를 듣는 첫번째 날이다. <br />
                      갈수록 어려워지겠지? <br />
                      기초부터 다시 단단히 잡으며 공부를 해야겠다.
                    </div>
                  </div>
                  <!-- <div class="inner">
                    <div class="title">문제 해결 과정</div>
                    <div class="contents">
                      1. 오늘 있었던 일을 정리한다.2. 오늘 발생했던 일에 대한
                      느낀 점을 작성한다.단순히 말로만 전달하는 것은 오해를
                      불러일으킬 수 있다.3. 문제가 있었다면 앞으로 개선 방안을
                      정리한다.앞으로는 회의 중 문서를 작성하여 모든 사람들이
                      제대로 이해할 수 있도록 하기로 했다
                    </div>
                  </div>

                  <strong>This is the first item's accordion body.</strong> It
                  is shown by default, until the collapse plugin adds the
                  appropriate classes that we use to style each element. These
                  classes control the overall appearance, as well as the showing
                  and hiding via CSS transitions. You can modify any of this
                  with custom CSS or overriding our default variables. It's also
                  worth noting that just about any HTML can go within the
                  <code>.accordion-body</code>, though the transition does limit
                  overflow. -->
                </div>
              </div>
            </div>
            <!-- items nd -->

            <!-- items st -->
            <div class="accordion-item">
              <h2 class="accordion-header">
                <button
                  class="accordion-button collapsed"
                  type="button"
                  data-bs-toggle="collapse"
                  data-bs-target="#collapse_2"
                  aria-expanded="false"
                  aria-controls="collapse_2"
                >
                  <span class="smalltxt">2024.04.19.금</span> 미니 프로젝트
                  마무리
                </button>
              </h2>
              <div
                id="collapse_2"
                class="accordion-collapse collapse"
                data-bs-parent="#accordionExample"
              >
                <div class="accordion-body">
                  <div class="inner">
                    <div class="title">개발 단계 정리 OR 오늘 배운 것</div>
                    <div class="contents">
                      1. 공통으로 작업해할 것 잡아놓기 (깃헙 커밋, 클래스명 등)
                      <br />
                      2. 분리될 수 있는 것들 잘 분리해놓기. 기능에 따라 파일
                      분리. 코드 분리!
                    </div>
                  </div>
                  <div class="inner">
                    <div class="title">하루 회고</div>
                    <div class="contents">
                      오늘은 첫번째 팀 프로젝트가 끝나는 날이다. <br />
                      첫 프로젝트는 html, css가 바탕이 되었던 프로젝트 같아,
                      기술적으로 어려움이 있었다기보단, <br />
                      협업을 잘 할수 있는 방법에 대해 생각해볼수 있던
                      프로젝트였다. <br />
                      많이 부족했지만 함께 따라와준 팀원들에게 고마웠고, 깃헙
                      룰에 대하여 좀 더 공부해봐야할 것 같다.
                    </div>
                  </div>
                  <!-- <div class="inner">
                    <div class="title">문제 해결 과정</div>
                    <div class="contents">
                      1. 이전 작업자가 시간이 딜레이 되었을 

                      <code> </code>
                    </div>
                  </div> -->
                </div>
              </div>
            </div>
            <!-- items nd -->

            <!-- items st -->
            <div class="accordion-item">
              <h2 class="accordion-header">
                <button
                  class="accordion-button collapsed"
                  type="button"
                  data-bs-toggle="collapse"
                  data-bs-target="#collapse_3"
                  aria-expanded="false"
                  aria-controls="collapse_3"
                >
                  <span class="smalltxt">2024.04.15.월</span>git 특강 / 미니
                  프로젝트 시작
                </button>
              </h2>
              <div
                id="collapse_3"
                class="accordion-collapse collapse"
                data-bs-parent="#accordionExample"
              >
                <div class="accordion-body">
                  <div class="inner">
                    <div class="title">강의 내용 정리</div>
                    <div class="contents">
                      git : 코드 변경 기록 (버전관리도구 / 형상솬리도구 /
                      소프트웨어의 변경사항을 체계적으로 추적하고 통제) <br />
                      git hub : 온라인 코드 저장소 (온라인 백업, 공유, 협업)
                      <br />

                      <ul>
                        <div class="title">😈 - git 특강</div>
                        <li>pwd : 현재 작업환경 확인</li>
                        <li>ls-a : 숨겨진 파일 설정들도 확인</li>
                        <li>cd 폴더명 : 폴더 이동</li>
                        <li>mkdir 폴더명 : 폴더 생성</li>
                        <li>touch 파일명 : 파일 생성</li>
                      </ul>
                    </div>
                  </div>
                  <div class="inner">
                    <div class="title">개발 단계 정리</div>
                    <div class="contents">
                      1. 팀 이름 만들기 - 코딩쉽지않조 <br />
                      2. 기본 셋팅 맞추기 (prettier, esLint 등) 3. 피그마로
                      와이어 프레임 잡아오지
                    </div>
                  </div>
                  <div class="inner">
                    <div class="title">하루 회고</div>
                    <div class="contents">
                      <code>
                        git init <br />
                        git add . <br />
                        git commit -m "커밋 메세지" <br />
                        git push
                        <br /><br />
                        git push (다른 사람 코드 가져오기) <br />
                      </code>
                      협업을 잘하려면 github에 익숙해져야겠다.
                    </div>
                  </div>
                  <!-- <div class="inner">
                    <div class="title">문제 해결 과정</div>
                    <div class="contents">
                      1. 오늘 있었던 일을 정리한다.2. 오늘 발생했던 일에 대한
                      느낀 점을 작성한다.단순히 말로만 전달하는 것은 오해를
                      불러일으킬 수 있다.3. 문제가 있었다면 앞으로 개선 방안을
                      정리한다.앞으로는 회의 중 문서를 작성하여 모든 사람들이
                      제대로 이해할 수 있도록 하기로 했다
                    </div>
                  </div> -->
                </div>
              </div>
            </div>
            <!-- items nd -->
          </div>
        </div>
      </div>

      <div class="footer">
        <ul>
          <li>@내일배움캠프</li>
          <li>@React 5기 - 국민영</li>
        </ul>
      </div>
    </div>
  </body>
</html>
